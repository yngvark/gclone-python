#!/usr/bin/env python3
import argparse
import os
import sys
from pathlib import Path
from subprocess import Popen, PIPE

DEFAULT_REPO_ENV_NAME = "REPONEW_DEFAULT_ORGANIZATION"


def parse_args():
    parser = argparse.ArgumentParser(description="Creates a new Github repository.")
    parser.add_argument("repoId", type=str, help="Organization (optinal) and repository name. Example: myorg/myrepo")
    parser.add_argument("-n", "--dry-run", action='store_true', help="Don't make any changes")
    parser.add_argument("-p", "--private", action='store_true', default=False, help="Make the new repository private")
    parser.add_argument("-t", "--template", type=str, help="repository for template. For instance 'myorg/mytemplaterepo'")
    parser.add_argument("-d", "--description", type=str, help="the description for the repository")

    # When python 3.9 arrives:
    # parser.add_argument("-d", "--dry-run", action=argparse.BooleanOptionalAction, help="Don't make any changes")
    # parser.add_argument("-p", "--private", action=argparse.BooleanOptionalAction, default=False, help="Make the new repository private")

    return parser.parse_args()


def print_err(txt):
    print(txt, file=sys.stderr)


def validate_args(args):
    error = False
    err = None

    if len(args.repoId.split("/")) > 2:
        err = "repoId must be on the form: org/repo"
        error = True

    if error:
        print_err("ERROR: " + str(err))
        sys.exit(1)


def get_organization(repoId):
    split = repoId.split("/")
    
    if len(split) == 1:
        org = default_org()
        if org == None:
            print_err("ERROR: You didn't provide a organization, and you haven't set the environment variable " \
                + DEFAULT_REPO_ENV_NAME + ", so it's impossible to figure out which organization to use.")
            sys.exit(1)
        return org

    return split[0]


def default_org():
    return os.environ.get("REPONEW_DEFAULT_ORGANIZATION")


def get_repository_name(repoId):
    return repoId.split("/")[-1]


def git_dir():
    dir = os.environ.get("GCLONE_GIT_DIR")
    if dir == None:
        raise "Missing environment variable GCLONE_GIT_DIR. Set it to the directory where you contain git " \
            + "repositories"
    
    return dir


def create_dir(dir):
    if os.path.exists(dir):
        print_err(f"ERROR: Directory already exists:")
        print_err(dir)
        sys.exit(1)

    #print_err(f"Creating directory {repoDir}")
    Path(repoDir).mkdir(parents=True, exist_ok=True)


def get_private_public_arg(privateArg):
    if privateArg:
        return "--private"

    return "--public"


def run_cmd(cmd, repoDir):
    print_err("Command: " + " ".join(cmd))
    p = Popen(cmd, cwd=repoDir, stdout=PIPE, stderr=PIPE)
    output, error = p.communicate()
    if p.returncode != 0: 
        print_err("ERROR, response from gh (exit code %d): %s %s" % (p.returncode, output, error))
        sys.exit(1)


args = parse_args()
# print_err("ARGS:")
# print_err(args)

validate_args(args)

org = get_organization(args.repoId)
repo = get_repository_name(args.repoId)
gitDir = git_dir()
repoDir = Path(gitDir).joinpath(org).joinpath(repo)
privatePublicArg = get_private_public_arg(args.private)

# print_err("org: " + org)
# print_err("repo: " + repo)

if not args.dry_run:
    create_dir(repoDir)
else:
    print_err(f"DRY-RUN: Would create dir {repoDir}")

org_with_repo = f"{org}/{repo}"

cmd = ["gh", "repo", "create", "--clone", org_with_repo, privatePublicArg]

if args.template is not None and len(args.template) > 0:
    cmd.append("--template")
    cmd.append(args.template)

if args.description is not None and len(args.description) > 0:
    cmd.append("--description")
    cmd.append(args.description)

if not args.dry_run:
    run_cmd(cmd, repoDir.parent)

print_err(f"Successfully created repository in directory " + str(repoDir))
print(repoDir)
